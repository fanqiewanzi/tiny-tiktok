// Code generated by Kitex v0.3.1. DO NOT EDIT.

package videoservice

import (
	"context"
	"fmt"
	"github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	"github.com/cloudwego/kitex/pkg/streaming"
	"github.com/weirdo0314/tiny-tiktok/kitex_gen/user"
	"github.com/weirdo0314/tiny-tiktok/kitex_gen/video"
	"google.golang.org/protobuf/proto"
)

func serviceInfo() *kitex.ServiceInfo {
	return videoServiceServiceInfo
}

var videoServiceServiceInfo = NewServiceInfo()

func NewServiceInfo() *kitex.ServiceInfo {
	serviceName := "VideoService"
	handlerType := (*video.VideoService)(nil)
	methods := map[string]kitex.MethodInfo{
		"Feed":           kitex.NewMethodInfo(feedHandler, newFeedArgs, newFeedResult, false),
		"Publish":        kitex.NewMethodInfo(publishHandler, newPublishArgs, newPublishResult, false),
		"MGetVideo":      kitex.NewMethodInfo(mGetVideoHandler, newMGetVideoArgs, newMGetVideoResult, false),
		"Favorite":       kitex.NewMethodInfo(favoriteHandler, newFavoriteArgs, newFavoriteResult, false),
		"CancelFavorite": kitex.NewMethodInfo(cancelFavoriteHandler, newCancelFavoriteArgs, newCancelFavoriteResult, false),
		"MGetFavorite":   kitex.NewMethodInfo(mGetFavoriteHandler, newMGetFavoriteArgs, newMGetFavoriteResult, false),
		"Comment":        kitex.NewMethodInfo(commentHandler, newCommentArgs, newCommentResult, false),
		"DeleteComment":  kitex.NewMethodInfo(deleteCommentHandler, newDeleteCommentArgs, newDeleteCommentResult, false),
		"MGetComment":    kitex.NewMethodInfo(mGetCommentHandler, newMGetCommentArgs, newMGetCommentResult, false),
	}
	extra := map[string]interface{}{
		"PackageName": "video",
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.3.1",
		Extra:           extra,
	}
	return svcInfo
}

func feedHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(video.FeedRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(video.VideoService).Feed(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *FeedArgs:
		success, err := handler.(video.VideoService).Feed(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*FeedResult)
		realResult.Success = success
	}
	return nil
}
func newFeedArgs() interface{} {
	return &FeedArgs{}
}

func newFeedResult() interface{} {
	return &FeedResult{}
}

type FeedArgs struct {
	Req *video.FeedRequest
}

func (p *FeedArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in FeedArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *FeedArgs) Unmarshal(in []byte) error {
	msg := new(video.FeedRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var FeedArgs_Req_DEFAULT *video.FeedRequest

func (p *FeedArgs) GetReq() *video.FeedRequest {
	if !p.IsSetReq() {
		return FeedArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *FeedArgs) IsSetReq() bool {
	return p.Req != nil
}

type FeedResult struct {
	Success *video.FeedResponse
}

var FeedResult_Success_DEFAULT *video.FeedResponse

func (p *FeedResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in FeedResult")
	}
	return proto.Marshal(p.Success)
}

func (p *FeedResult) Unmarshal(in []byte) error {
	msg := new(video.FeedResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *FeedResult) GetSuccess() *video.FeedResponse {
	if !p.IsSetSuccess() {
		return FeedResult_Success_DEFAULT
	}
	return p.Success
}

func (p *FeedResult) SetSuccess(x interface{}) {
	p.Success = x.(*video.FeedResponse)
}

func (p *FeedResult) IsSetSuccess() bool {
	return p.Success != nil
}

func publishHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(video.PublishActionRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(video.VideoService).Publish(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *PublishArgs:
		success, err := handler.(video.VideoService).Publish(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*PublishResult)
		realResult.Success = success
	}
	return nil
}
func newPublishArgs() interface{} {
	return &PublishArgs{}
}

func newPublishResult() interface{} {
	return &PublishResult{}
}

type PublishArgs struct {
	Req *video.PublishActionRequest
}

func (p *PublishArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in PublishArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *PublishArgs) Unmarshal(in []byte) error {
	msg := new(video.PublishActionRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var PublishArgs_Req_DEFAULT *video.PublishActionRequest

func (p *PublishArgs) GetReq() *video.PublishActionRequest {
	if !p.IsSetReq() {
		return PublishArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *PublishArgs) IsSetReq() bool {
	return p.Req != nil
}

type PublishResult struct {
	Success *user.BaseResponse
}

var PublishResult_Success_DEFAULT *user.BaseResponse

func (p *PublishResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in PublishResult")
	}
	return proto.Marshal(p.Success)
}

func (p *PublishResult) Unmarshal(in []byte) error {
	msg := new(user.BaseResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *PublishResult) GetSuccess() *user.BaseResponse {
	if !p.IsSetSuccess() {
		return PublishResult_Success_DEFAULT
	}
	return p.Success
}

func (p *PublishResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.BaseResponse)
}

func (p *PublishResult) IsSetSuccess() bool {
	return p.Success != nil
}

func mGetVideoHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(video.PublishListRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(video.VideoService).MGetVideo(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *MGetVideoArgs:
		success, err := handler.(video.VideoService).MGetVideo(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*MGetVideoResult)
		realResult.Success = success
	}
	return nil
}
func newMGetVideoArgs() interface{} {
	return &MGetVideoArgs{}
}

func newMGetVideoResult() interface{} {
	return &MGetVideoResult{}
}

type MGetVideoArgs struct {
	Req *video.PublishListRequest
}

func (p *MGetVideoArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in MGetVideoArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *MGetVideoArgs) Unmarshal(in []byte) error {
	msg := new(video.PublishListRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var MGetVideoArgs_Req_DEFAULT *video.PublishListRequest

func (p *MGetVideoArgs) GetReq() *video.PublishListRequest {
	if !p.IsSetReq() {
		return MGetVideoArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *MGetVideoArgs) IsSetReq() bool {
	return p.Req != nil
}

type MGetVideoResult struct {
	Success *video.PublishListResponse
}

var MGetVideoResult_Success_DEFAULT *video.PublishListResponse

func (p *MGetVideoResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in MGetVideoResult")
	}
	return proto.Marshal(p.Success)
}

func (p *MGetVideoResult) Unmarshal(in []byte) error {
	msg := new(video.PublishListResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *MGetVideoResult) GetSuccess() *video.PublishListResponse {
	if !p.IsSetSuccess() {
		return MGetVideoResult_Success_DEFAULT
	}
	return p.Success
}

func (p *MGetVideoResult) SetSuccess(x interface{}) {
	p.Success = x.(*video.PublishListResponse)
}

func (p *MGetVideoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func favoriteHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(video.FavoriteActionRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(video.VideoService).Favorite(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *FavoriteArgs:
		success, err := handler.(video.VideoService).Favorite(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*FavoriteResult)
		realResult.Success = success
	}
	return nil
}
func newFavoriteArgs() interface{} {
	return &FavoriteArgs{}
}

func newFavoriteResult() interface{} {
	return &FavoriteResult{}
}

type FavoriteArgs struct {
	Req *video.FavoriteActionRequest
}

func (p *FavoriteArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in FavoriteArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *FavoriteArgs) Unmarshal(in []byte) error {
	msg := new(video.FavoriteActionRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var FavoriteArgs_Req_DEFAULT *video.FavoriteActionRequest

func (p *FavoriteArgs) GetReq() *video.FavoriteActionRequest {
	if !p.IsSetReq() {
		return FavoriteArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *FavoriteArgs) IsSetReq() bool {
	return p.Req != nil
}

type FavoriteResult struct {
	Success *user.BaseResponse
}

var FavoriteResult_Success_DEFAULT *user.BaseResponse

func (p *FavoriteResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in FavoriteResult")
	}
	return proto.Marshal(p.Success)
}

func (p *FavoriteResult) Unmarshal(in []byte) error {
	msg := new(user.BaseResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *FavoriteResult) GetSuccess() *user.BaseResponse {
	if !p.IsSetSuccess() {
		return FavoriteResult_Success_DEFAULT
	}
	return p.Success
}

func (p *FavoriteResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.BaseResponse)
}

func (p *FavoriteResult) IsSetSuccess() bool {
	return p.Success != nil
}

func cancelFavoriteHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(video.FavoriteActionRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(video.VideoService).CancelFavorite(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CancelFavoriteArgs:
		success, err := handler.(video.VideoService).CancelFavorite(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CancelFavoriteResult)
		realResult.Success = success
	}
	return nil
}
func newCancelFavoriteArgs() interface{} {
	return &CancelFavoriteArgs{}
}

func newCancelFavoriteResult() interface{} {
	return &CancelFavoriteResult{}
}

type CancelFavoriteArgs struct {
	Req *video.FavoriteActionRequest
}

func (p *CancelFavoriteArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CancelFavoriteArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CancelFavoriteArgs) Unmarshal(in []byte) error {
	msg := new(video.FavoriteActionRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CancelFavoriteArgs_Req_DEFAULT *video.FavoriteActionRequest

func (p *CancelFavoriteArgs) GetReq() *video.FavoriteActionRequest {
	if !p.IsSetReq() {
		return CancelFavoriteArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CancelFavoriteArgs) IsSetReq() bool {
	return p.Req != nil
}

type CancelFavoriteResult struct {
	Success *user.BaseResponse
}

var CancelFavoriteResult_Success_DEFAULT *user.BaseResponse

func (p *CancelFavoriteResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CancelFavoriteResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CancelFavoriteResult) Unmarshal(in []byte) error {
	msg := new(user.BaseResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CancelFavoriteResult) GetSuccess() *user.BaseResponse {
	if !p.IsSetSuccess() {
		return CancelFavoriteResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CancelFavoriteResult) SetSuccess(x interface{}) {
	p.Success = x.(*user.BaseResponse)
}

func (p *CancelFavoriteResult) IsSetSuccess() bool {
	return p.Success != nil
}

func mGetFavoriteHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(video.FavoriteListRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(video.VideoService).MGetFavorite(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *MGetFavoriteArgs:
		success, err := handler.(video.VideoService).MGetFavorite(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*MGetFavoriteResult)
		realResult.Success = success
	}
	return nil
}
func newMGetFavoriteArgs() interface{} {
	return &MGetFavoriteArgs{}
}

func newMGetFavoriteResult() interface{} {
	return &MGetFavoriteResult{}
}

type MGetFavoriteArgs struct {
	Req *video.FavoriteListRequest
}

func (p *MGetFavoriteArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in MGetFavoriteArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *MGetFavoriteArgs) Unmarshal(in []byte) error {
	msg := new(video.FavoriteListRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var MGetFavoriteArgs_Req_DEFAULT *video.FavoriteListRequest

func (p *MGetFavoriteArgs) GetReq() *video.FavoriteListRequest {
	if !p.IsSetReq() {
		return MGetFavoriteArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *MGetFavoriteArgs) IsSetReq() bool {
	return p.Req != nil
}

type MGetFavoriteResult struct {
	Success *video.FavoriteListResponse
}

var MGetFavoriteResult_Success_DEFAULT *video.FavoriteListResponse

func (p *MGetFavoriteResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in MGetFavoriteResult")
	}
	return proto.Marshal(p.Success)
}

func (p *MGetFavoriteResult) Unmarshal(in []byte) error {
	msg := new(video.FavoriteListResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *MGetFavoriteResult) GetSuccess() *video.FavoriteListResponse {
	if !p.IsSetSuccess() {
		return MGetFavoriteResult_Success_DEFAULT
	}
	return p.Success
}

func (p *MGetFavoriteResult) SetSuccess(x interface{}) {
	p.Success = x.(*video.FavoriteListResponse)
}

func (p *MGetFavoriteResult) IsSetSuccess() bool {
	return p.Success != nil
}

func commentHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(video.CommentActionRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(video.VideoService).Comment(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CommentArgs:
		success, err := handler.(video.VideoService).Comment(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CommentResult)
		realResult.Success = success
	}
	return nil
}
func newCommentArgs() interface{} {
	return &CommentArgs{}
}

func newCommentResult() interface{} {
	return &CommentResult{}
}

type CommentArgs struct {
	Req *video.CommentActionRequest
}

func (p *CommentArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CommentArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CommentArgs) Unmarshal(in []byte) error {
	msg := new(video.CommentActionRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CommentArgs_Req_DEFAULT *video.CommentActionRequest

func (p *CommentArgs) GetReq() *video.CommentActionRequest {
	if !p.IsSetReq() {
		return CommentArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CommentArgs) IsSetReq() bool {
	return p.Req != nil
}

type CommentResult struct {
	Success *video.CommentActionResponse
}

var CommentResult_Success_DEFAULT *video.CommentActionResponse

func (p *CommentResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CommentResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CommentResult) Unmarshal(in []byte) error {
	msg := new(video.CommentActionResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CommentResult) GetSuccess() *video.CommentActionResponse {
	if !p.IsSetSuccess() {
		return CommentResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CommentResult) SetSuccess(x interface{}) {
	p.Success = x.(*video.CommentActionResponse)
}

func (p *CommentResult) IsSetSuccess() bool {
	return p.Success != nil
}

func deleteCommentHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(video.CommentActionRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(video.VideoService).DeleteComment(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *DeleteCommentArgs:
		success, err := handler.(video.VideoService).DeleteComment(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*DeleteCommentResult)
		realResult.Success = success
	}
	return nil
}
func newDeleteCommentArgs() interface{} {
	return &DeleteCommentArgs{}
}

func newDeleteCommentResult() interface{} {
	return &DeleteCommentResult{}
}

type DeleteCommentArgs struct {
	Req *video.CommentActionRequest
}

func (p *DeleteCommentArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in DeleteCommentArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *DeleteCommentArgs) Unmarshal(in []byte) error {
	msg := new(video.CommentActionRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var DeleteCommentArgs_Req_DEFAULT *video.CommentActionRequest

func (p *DeleteCommentArgs) GetReq() *video.CommentActionRequest {
	if !p.IsSetReq() {
		return DeleteCommentArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *DeleteCommentArgs) IsSetReq() bool {
	return p.Req != nil
}

type DeleteCommentResult struct {
	Success *video.CommentActionResponse
}

var DeleteCommentResult_Success_DEFAULT *video.CommentActionResponse

func (p *DeleteCommentResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in DeleteCommentResult")
	}
	return proto.Marshal(p.Success)
}

func (p *DeleteCommentResult) Unmarshal(in []byte) error {
	msg := new(video.CommentActionResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *DeleteCommentResult) GetSuccess() *video.CommentActionResponse {
	if !p.IsSetSuccess() {
		return DeleteCommentResult_Success_DEFAULT
	}
	return p.Success
}

func (p *DeleteCommentResult) SetSuccess(x interface{}) {
	p.Success = x.(*video.CommentActionResponse)
}

func (p *DeleteCommentResult) IsSetSuccess() bool {
	return p.Success != nil
}

func mGetCommentHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(video.CommentListRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(video.VideoService).MGetComment(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *MGetCommentArgs:
		success, err := handler.(video.VideoService).MGetComment(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*MGetCommentResult)
		realResult.Success = success
	}
	return nil
}
func newMGetCommentArgs() interface{} {
	return &MGetCommentArgs{}
}

func newMGetCommentResult() interface{} {
	return &MGetCommentResult{}
}

type MGetCommentArgs struct {
	Req *video.CommentListRequest
}

func (p *MGetCommentArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in MGetCommentArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *MGetCommentArgs) Unmarshal(in []byte) error {
	msg := new(video.CommentListRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var MGetCommentArgs_Req_DEFAULT *video.CommentListRequest

func (p *MGetCommentArgs) GetReq() *video.CommentListRequest {
	if !p.IsSetReq() {
		return MGetCommentArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *MGetCommentArgs) IsSetReq() bool {
	return p.Req != nil
}

type MGetCommentResult struct {
	Success *video.CommentListResponse
}

var MGetCommentResult_Success_DEFAULT *video.CommentListResponse

func (p *MGetCommentResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in MGetCommentResult")
	}
	return proto.Marshal(p.Success)
}

func (p *MGetCommentResult) Unmarshal(in []byte) error {
	msg := new(video.CommentListResponse)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *MGetCommentResult) GetSuccess() *video.CommentListResponse {
	if !p.IsSetSuccess() {
		return MGetCommentResult_Success_DEFAULT
	}
	return p.Success
}

func (p *MGetCommentResult) SetSuccess(x interface{}) {
	p.Success = x.(*video.CommentListResponse)
}

func (p *MGetCommentResult) IsSetSuccess() bool {
	return p.Success != nil
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) Feed(ctx context.Context, Req *video.FeedRequest) (r *video.FeedResponse, err error) {
	var _args FeedArgs
	_args.Req = Req
	var _result FeedResult
	if err = p.c.Call(ctx, "Feed", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) Publish(ctx context.Context, Req *video.PublishActionRequest) (r *user.BaseResponse, err error) {
	var _args PublishArgs
	_args.Req = Req
	var _result PublishResult
	if err = p.c.Call(ctx, "Publish", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) MGetVideo(ctx context.Context, Req *video.PublishListRequest) (r *video.PublishListResponse, err error) {
	var _args MGetVideoArgs
	_args.Req = Req
	var _result MGetVideoResult
	if err = p.c.Call(ctx, "MGetVideo", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) Favorite(ctx context.Context, Req *video.FavoriteActionRequest) (r *user.BaseResponse, err error) {
	var _args FavoriteArgs
	_args.Req = Req
	var _result FavoriteResult
	if err = p.c.Call(ctx, "Favorite", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) CancelFavorite(ctx context.Context, Req *video.FavoriteActionRequest) (r *user.BaseResponse, err error) {
	var _args CancelFavoriteArgs
	_args.Req = Req
	var _result CancelFavoriteResult
	if err = p.c.Call(ctx, "CancelFavorite", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) MGetFavorite(ctx context.Context, Req *video.FavoriteListRequest) (r *video.FavoriteListResponse, err error) {
	var _args MGetFavoriteArgs
	_args.Req = Req
	var _result MGetFavoriteResult
	if err = p.c.Call(ctx, "MGetFavorite", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) Comment(ctx context.Context, Req *video.CommentActionRequest) (r *video.CommentActionResponse, err error) {
	var _args CommentArgs
	_args.Req = Req
	var _result CommentResult
	if err = p.c.Call(ctx, "Comment", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) DeleteComment(ctx context.Context, Req *video.CommentActionRequest) (r *video.CommentActionResponse, err error) {
	var _args DeleteCommentArgs
	_args.Req = Req
	var _result DeleteCommentResult
	if err = p.c.Call(ctx, "DeleteComment", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) MGetComment(ctx context.Context, Req *video.CommentListRequest) (r *video.CommentListResponse, err error) {
	var _args MGetCommentArgs
	_args.Req = Req
	var _result MGetCommentResult
	if err = p.c.Call(ctx, "MGetComment", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
